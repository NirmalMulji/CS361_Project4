UTEID: nre299; npm435;
FIRSTNAME: Nick; Nirmal;
LASTNAME: Eckert; Mulji;
CSACCOUNT: neckert; nirmal95;
EMAIL: nickeckert@utexas.edu; nirmalmulji@utexas.edu;

[Program 4]
[Description]

This project has two files, Encoder.java and Huffman.java. 

Huffman.java was taken from http://rextester.com/SHCJG53321 and edited to work with Encoder.java. We had to change it so it would take in strings as symbols instead of a single character so we could use the algorithm for 2-symbol encoding. We then had to change the constructor so it could take in a mapping of symbols to frequencies since this was originally hard coded within the class file. Finally we had to comment out two lines of code to prevent printing the source tree since we didn't need that in our final output.

Encoder.java first generates a text file containing k characters. It does this by first reading frequencies from the provided file of frequencies from the command line where each n frequency corresponds to the first n letters in the English alphabet. It then creates ranges out of one hundred that correspond to each individual frequency so we can randomly generate numbers between 1 and 100 and assign letters based on there they fall. This is written to testText.txt

Encoder then uses huffman.java to generate an encoding given a map of symbols and frequencies. We build a mapping from English letters to their corresponding frequency and give this to the Huffman algorithm and receive back a mapping from symbol to bit-string. We use this mapping to encode testText by reading each character and writing its corresponding bit-string to enc1.txt. This is done in the method "encode1" written by Nirmal.

The mapping is then reversed for decoding. To decode we read each bit from enc1.txt and search the reversed mapping to see if it exists. Since the encoding is prefix free we can just go until we find a match each time. each match is looked up in the reversed map to get the symbol based on the bit-string from enc1. This is written to dec1 and matches the original textText. This is done in decode1 written by Nick. The methods "encode1" and "decode1" are for 1-symbol encoding.

Entropy is calculated by dividing each frequency by the total occurrences of all symbols in the language. This is then plugged into the entropy formula found in the method called "entropy" written by Nirmal.

2-symbol encoding is generated by passing in pairs of characters in the English language such as "AA, AB, ... ZZ". Encoding is largely calculated the same as 1-symbol encoding except that when encoding two characters are read in from testText two at time instead of one. This is done in the "encode2" method written by Nick. Decoding is no different except for writing to a different file "dec2.txt." This is done in "decode2" written by Nirmal.

Entropy for 2-symbol encoding is calculated by multiplying the frequencies of each symbol by the single symbols that they're made up of. The same method is used just with a different array of probabilities corresponding to each symbol in the alphabet.

At the end a summary of percent difference between each different encoding is printed to console.

[Finish]
We finished all of the assignment. There are no bugs.

[Test Case 1]

[Command line]
$ javac Encoder.java 
$ java Encoder test.txt 100

[Input]
4
2
3
1

[Output]
Single symbol encoding: 

A : 0
C : 10
D : 110
B : 111

Two symbol encoding: 

DA : 0000
DB : 00010
DD : 000110
BD : 000111
CC : 001
CA : 010
BC : 0110
CB : 0111
AC : 100
DC : 10100
CD : 10101
AB : 1011
BA : 1100
AD : 11010
BB : 11011
AA : 111

-----------------------------------------------------
Summary of results: 

Computed entropy of the language: 1.846

1-symbol actual average bits/symbol: 1.910
Percent difference 1-symbol vs theoretical: %3.442

2-symbol actual average bits/symbol: 1.890
Percent difference 2-symbol vs theoretical: %2.359

Percent difference 2-symbol vs 1-symbol: %1.058

[Test Case 2]

[Command line]
$ java Encoder test.txt 200

[Input]
4
2
3
1
3
7
1

[Output]

Single symbol encoding: 

A : 00
B : 010
D : 0110
G : 0111
E : 100
C : 101
F : 11

Two symbol encoding: 

FC : 0000
FE : 0001
BC : 001000
CB : 001001
CD : 0010100
GE : 0010101
ED : 0010110
EG : 0010111
BE : 001100
EB : 001101
AE : 00111
AC : 01000
CA : 01001
DC : 0101000
DE : 0101001
GC : 0101010
CG : 0101011
EA : 01011
FF : 011
FA : 1000
BF : 10010
DF : 100110
GF : 100111
FB : 10100
FD : 101010
FG : 101011
AF : 1011
AB : 110000
BA : 110001
DG : 110010000
GG : 110010001
BG : 11001001
AG : 1100101
BB : 1100110
GA : 1100111
DA : 1101000
AD : 1101001
DD : 110101000
GD : 110101001
BD : 11010101
DB : 11010110
GB : 11010111
AA : 11011
CE : 111000
EC : 111001
EE : 111010
CC : 111011
CF : 11110
EF : 11111

-----------------------------------------------------
Summary of results: 

Computed entropy of the language: 2.527

1-symbol actual average bits/symbol: 2.605
Percent difference 1-symbol vs theoretical: %3.066

2-symbol actual average bits/symbol: 2.580
Percent difference 2-symbol vs theoretical: %2.077

Percent difference 2-symbol vs 1-symbol: %0.969


[Test Case 3]

[Command line]
$ java Encoder test.txt 350

[Input]
1
2
1
2
1
2
1
2
1
2
1
2
1
2

[Output]

Single symbol encoding: 

J : 000
A : 0010
E : 0011
I : 0100
K : 0101
B : 011
L : 100
G : 1010
C : 10110
M : 10111
D : 1100
N : 1101
H : 1110
F : 1111

Two symbol encoding: 

DD : 000000
CG : 00000100
EM : 00000101
KJ : 0000011
LK : 0000100
FM : 0000101
FH : 000011
FD : 000100
ML : 0001010
AJ : 0001011
GC : 00011000
ME : 00011001
AB : 0001101
LH : 000111
JD : 001000
IL : 0010010
BM : 0010011
HN : 001010
BN : 001011
HC : 0011000
DI : 0011001
HA : 0011010
BK : 0011011
GL : 0011100
GN : 0011101
NF : 001111
GB : 0100000
EC : 01000010
IE : 01000011
BA : 0100010
IM : 01000110
IK : 010001110
EG : 010001111
GM : 010010000
AG : 010010001
ID : 01001001
IH : 01001010
EE : 010010110
II : 010010111
HE : 01001100
AF : 01001101
IN : 01001110
HG : 01001111
HL : 0101000
IG : 010100100
CC : 010100101
MF : 01010011
AN : 01010100
MJ : 01010101
GD : 01010110
AC : 010101110
AM : 010101111
ED : 01011000
HM : 01011001
NB : 0101101
IJ : 01011100
DM : 01011101
DB : 0101111
HB : 0110000
FJ : 0110001
HD : 0110010
KG : 011001100
KI : 011001101
EI : 011001110
EK : 011001111
EB : 01101000
IF : 01101001
IB : 01101010
CA : 011010110
EA : 011010111
DN : 0110110
IA : 011011100
IC : 011011101
DA : 01101111
DH : 0111000
NM : 01110010
AH : 01110011
BB : 0111010
GI : 011101100
GK : 011101101
AL : 01110111
JJ : 0111100
BF : 0111101
JB : 0111110
EF : 01111110
HI : 01111111
JL : 1000000
LA : 10000010
CH : 10000011
JN : 1000010
LF : 1000011
AA : 100010000
AE : 100010001
EL : 10001001
BI : 10001010
NC : 10001011
GJ : 10001100
DE : 10001101
LJ : 1000111
BH : 1001000
JK : 10010010
CF : 10010011
CD : 10010100
JI : 10010101
KB : 10010110
FA : 10010111
DG : 10011000
NK : 10011001
JC : 10011010
EH : 10011011
DJ : 1001110
FN : 1001111
FB : 1010000
KD : 10100010
AD : 10100011
NL : 1010010
BD : 1010011
NJ : 1010100
KA : 101010100
KC : 101010101
FC : 10101011
FK : 10101100
LG : 10101101
FF : 1010111
NN : 1011000
JF : 1011001
ND : 1011010
EJ : 10110110
JG : 10110111
LB : 1011100
JH : 1011101
BC : 10111100
EN : 10111101
NH : 1011111
NA : 11000000
DC : 11000001
NE : 11000010
MD : 11000011
CM : 110001000
GA : 110001001
KK : 110001010
CK : 110001011
LI : 11000110
CL : 11000111
JA : 11001000
DK : 11001001
CB : 11001010
HK : 11001011
HH : 1100110
LL : 1100111
MH : 11010000
MA : 110100010
MC : 110100011
CJ : 11010010
KL : 11010011
LC : 11010100
FI : 11010101
KN : 11010110
KH : 11010111
BG : 11011000
MB : 11011001
KF : 11011010
NI : 11011011
KM : 110111000
AK : 110111001
GG : 110111010
MI : 110111011
LD : 1101111
DL : 1110000
GH : 11100010
MG : 111000110
GE : 111000111
HF : 1110010
CN : 11100110
MK : 111001110
MM : 111001111
HJ : 1110100
LE : 11101010
NG : 11101011
FL : 1110110
LN : 1110111
BL : 1111000
JM : 11110010
AI : 111100110
CE : 111100111
FG : 11110100
BE : 11110101
FE : 11110110
CI : 111101110
KE : 111101111
DF : 1111100
GF : 11111010
MN : 11111011
BJ : 1111110
LM : 11111110
JE : 11111111

-----------------------------------------------------
Summary of results: 

Computed entropy of the language: 3.726

1-symbol actual average bits/symbol: 3.851
Percent difference 1-symbol vs theoretical: %3.376

2-symbol actual average bits/symbol: 3.751
Percent difference 2-symbol vs theoretical: %0.692

Percent difference 2-symbol vs 1-symbol: %2.666

[Test Case 4]

[Command line]
$ java Encoder test.txt 500

[Input]
1
2
3
4
5
6

[Output]

Single symbol encoding: 

D : 00
E : 01
C : 100
A : 1010
B : 1011
F : 11

Two symbol encoding: 

AE : 000000
EA : 000001
BE : 00001
ED : 0001
EB : 00100
FB : 00101
FD : 0011
CD : 01000
CA : 0100100
AC : 0100101
BC : 010011
DF : 0101
DC : 01100
BF : 01101
EE : 0111
AF : 100000
CB : 100001
FA : 100010
AD : 1000110
BB : 1000111
EF : 1001
FE : 1010
CE : 10110
EC : 10111
BD : 110000
DB : 110001
DD : 11001
FF : 1101
CC : 111000
DA : 1110010
BA : 11100110
AA : 111001110
AB : 111001111
CF : 11101
FC : 11110
DE : 11111

-----------------------------------------------------
Summary of results: 

Computed entropy of the language: 2.398

1-symbol actual average bits/symbol: 2.476
Percent difference 1-symbol vs theoretical: %3.240

2-symbol actual average bits/symbol: 2.452
Percent difference 2-symbol vs theoretical: %2.239

Percent difference 2-symbol vs 1-symbol: %0.979

